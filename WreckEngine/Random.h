#pragma once

#include "Time.h"

#include <limits>
#include <random>

namespace Random {

    struct well512 {
        typedef uint32_t result_type;
        static constexpr result_type min() { return std::numeric_limits<result_type>::min(); }
        static constexpr result_type max() { return std::numeric_limits<result_type>::max(); }

        static bool seeded;
        static result_type state[16];
        static result_type seed(result_type seedVal);
        result_type operator()();
    };

    // period 2^128-1
    struct xorshift128plus {
        typedef uint64_t result_type;
        static constexpr result_type min() { return std::numeric_limits<result_type>::min(); }
        static constexpr result_type max() { return std::numeric_limits<result_type>::max(); }

        static bool seeded;
        static result_type state[2];
        static result_type seed(result_type seedVal);
        result_type operator()();
    };

    using engine_t = well512;
    extern thread_local engine_t engine;

    inline auto seed() {
        return engine_t::seed((engine_t::result_type) Time::ctime());
    }

    namespace detail {
        template<typename T, typename Enable = void> struct random_impl {};

        template<typename T> 
        struct random_impl<T, std::enable_if_t<std::is_integral_v<T> && std::is_unsigned_v<T> && sizeof(T) <= sizeof(engine_t::result_type)>> {
            static auto getRange(T start, T end) {
                static auto do_seed = engine_t::seeded ? 0 : seed();
                return std::uniform_int_distribution<T>(start, end)(engine); 
            }
            static auto get() { return getRange(std::numeric_limits<T>::min(), std::numeric_limits<T>::max()); }
        };

        template<typename T>
        struct random_impl<T, std::enable_if_t<std::is_integral_v<T> && std::is_signed_v<T> && sizeof(T) <= sizeof(engine_t::result_type)>> {
            using uT = std::make_unsigned_t<T>;
            static auto getRange(T start, T end) {
                return (T)random_impl<uT>::getRange(0, (uT)(end - start)) + start;
            }
            static auto get() { return (random_impl<bool>::get() ? 1 : -1) * getRange(0, std::numeric_limits<T>::max()); }
        };

        template<typename T>
        struct random_impl<T, std::enable_if_t<std::is_floating_point_v<T> && sizeof(T) <= sizeof(engine_t::result_type)>> {
            static auto getRange(T start, T end) {
                static auto do_seed = engine_t::seeded ? 0 : seed();
                return std::uniform_real_distribution<T>(start, end)(engine);
            }
            static auto get() { return getRange(std::numeric_limits<T>::min(), std::numeric_limits<T>::max()); }
        };

        template<> struct random_impl<bool> {
            static auto get() { return (random_impl<engine_t::result_type>::get() & 1) == 0; }
            static auto getRange(bool, bool) { return get(); }
        };
    }

    // returns a value directly generated by the random engine
    template<typename T = engine_t::result_type> inline T get() { return detail::random_impl<T>::get(); }

    // gets a random value within the range provided
    template<typename S, typename T>
    inline auto getRange(S start, T end) {
        using common = std::common_type_t<S, T>;
        return detail::random_impl<common>::getRange(common{ start }, common{ end });
    }
};